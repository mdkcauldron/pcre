
svn diff -r1453:1454 svn://vcs.exim.org/pcre/code/trunk

diff -Naurp pcre-8.34/doc/pcreapi.3 pcre-8.34.oden/doc/pcreapi.3
--- pcre-8.34/doc/pcreapi.3	2013-11-19 16:33:00.000000000 +0100
+++ pcre-8.34.oden/doc/pcreapi.3	2014-02-19 14:59:22.963057477 +0100
@@ -116,6 +116,8 @@ PCRE - Perl-compatible regular expressio
 .B void (*pcre_stack_free)(void *);
 .sp
 .B int (*pcre_callout)(pcre_callout_block *);
+.sp
+.B int (*pcre_stack_guard)(void);
 .fi
 .
 .
@@ -286,6 +288,14 @@ points during a matching operation. Deta
 \fBpcrecallout\fP
 .\"
 documentation.
+.P
+The global variable \fBpcre_stack_guard\fP initially contains NULL. It can be 
+set by the caller to a function that is called by PCRE whenever it starts 
+to compile a parenthesized part of a pattern. When parentheses are nested, PCRE 
+uses recursive function calls, which use up the system stack. This function is 
+provided so that applications with restricted stacks can force a compilation 
+error if the stack runs out. The function should return zero if all is well, or 
+non-zero to force an error.
 .
 .
 .\" HTML <a name="newlines"></a>
@@ -337,7 +347,8 @@ controlled in a similar way, but by sepa
 The PCRE functions can be used in multi-threading applications, with the
 proviso that the memory management functions pointed to by \fBpcre_malloc\fP,
 \fBpcre_free\fP, \fBpcre_stack_malloc\fP, and \fBpcre_stack_free\fP, and the
-callout function pointed to by \fBpcre_callout\fP, are shared by all threads.
+callout and stack-checking functions pointed to by \fBpcre_callout\fP and 
+\fBpcre_stack_guard\fP, are shared by all threads.
 .P
 The compiled form of a regular expression is not altered during matching, so
 the same compiled pattern can safely be used by several threads at once.
@@ -465,7 +476,10 @@ documentation.
 The output is a long integer that gives the maximum depth of nesting of
 parentheses (of any kind) in a pattern. This limit is imposed to cap the amount
 of system stack used when a pattern is compiled. It is specified when PCRE is
-built; the default is 250.
+built; the default is 250. This limit does not take into account the stack that 
+may already be used by the calling application. For finer control over 
+compilation stack usage, you can set a pointer to an external checking function
+in \fBpcre_stack_guard\fP.
 .sp
   PCRE_CONFIG_MATCH_LIMIT
 .sp
@@ -991,6 +1005,8 @@ have fallen out of use. To avoid confusi
   81  missing opening brace after \eo
   82  parentheses are too deeply nested
   83  invalid range in character class
+  84  group name must start with a non-digit
+  85  parentheses are too deeply nested (stack check)  
 .sp
 The numbers 32 and 10000 in errors 48 and 49 are defaults; different values may
 be used if the limits were changed when PCRE was built.
diff -Naurp pcre-8.34/doc/pcretest.1 pcre-8.34.oden/doc/pcretest.1
--- pcre-8.34/doc/pcretest.1	2013-11-19 16:33:00.000000000 +0100
+++ pcre-8.34.oden/doc/pcretest.1	2014-02-19 14:59:22.964057477 +0100
@@ -330,6 +330,7 @@ sections.
   \fB/N\fP              set PCRE_NO_AUTO_CAPTURE
   \fB/O\fP              set PCRE_NO_AUTO_POSSESS
   \fB/P\fP              use the POSIX wrapper
+  \fB/Q\fP              test external stack check function 
   \fB/S\fP              study the pattern after compilation
   \fB/s\fP              set PCRE_DOTALL
   \fB/T\fP              select character tables
@@ -513,6 +514,15 @@ the compiled pattern to be output. This
 successfully studied with the PCRE_STUDY_JIT_COMPILE option, the size of the
 JIT compiled code is also output.
 .P
+The \fB/Q\fP modifier is used to test the use of \fBpcre_stack_guard\fP. It 
+must be followed by '0' or '1', specifying the return code to be given from an 
+external function that is passed to PCRE and used for stack checking during 
+compilation (see the
+.\" HREF
+\fBpcreapi\fP
+.\"
+documentation for details). 
+.P
 The \fB/S\fP modifier causes \fBpcre[16|32]_study()\fP to be called after the
 expression has been compiled, and the results used when the expression is
 matched. There are a number of qualifying characters that may follow \fB/S\fP.
diff -Naurp pcre-8.34/pcre_compile.c pcre-8.34.oden/pcre_compile.c
--- pcre-8.34/pcre_compile.c	2013-12-15 17:56:22.000000000 +0100
+++ pcre-8.34.oden/pcre_compile.c	2014-02-19 14:59:22.975057478 +0100
@@ -547,6 +547,8 @@ static const char error_texts[] =
   "parentheses are too deeply nested\0"
   "invalid range in character class\0"
   "group name must start with a non-digit\0"
+  /* 85 */
+  "parentheses are too deeply nested (stack check)\0"  
   ;
 
 /* Table to identify digits and hex digits. This is used when compiling
@@ -7994,6 +7996,16 @@ unsigned int orig_bracount;
 unsigned int max_bracount;
 branch_chain bc;
 
+/* If set, call the external function that checks for stack availability. */
+
+if (PUBL(stack_guard) != NULL && PUBL(stack_guard)())
+  {
+  *errorcodeptr= ERR85;
+  return FALSE;
+  }
+  
+/* Miscellaneous initialization */ 
+
 bc.outer = bcptr;
 bc.current_branch = code;
 
diff -Naurp pcre-8.34/pcre_globals.c pcre-8.34.oden/pcre_globals.c
--- pcre-8.34/pcre_globals.c	2012-01-05 18:07:07.000000000 +0100
+++ pcre-8.34.oden/pcre_globals.c	2014-02-19 14:59:22.970057477 +0100
@@ -72,6 +72,7 @@ PCRE_EXP_DATA_DEFN void  (*PUBL(free))(v
 PCRE_EXP_DATA_DEFN void *(*PUBL(stack_malloc))(size_t) = LocalPcreMalloc;
 PCRE_EXP_DATA_DEFN void  (*PUBL(stack_free))(void *) = LocalPcreFree;
 PCRE_EXP_DATA_DEFN int   (*PUBL(callout))(PUBL(callout_block) *) = NULL;
+PCRE_EXP_DATA_DEFN int   (*PUBL(stack_guard))(void) = NULL;
 
 #elif !defined VPCOMPAT
 PCRE_EXP_DATA_DEFN void *(*PUBL(malloc))(size_t) = malloc;
@@ -79,6 +80,7 @@ PCRE_EXP_DATA_DEFN void  (*PUBL(free))(v
 PCRE_EXP_DATA_DEFN void *(*PUBL(stack_malloc))(size_t) = malloc;
 PCRE_EXP_DATA_DEFN void  (*PUBL(stack_free))(void *) = free;
 PCRE_EXP_DATA_DEFN int   (*PUBL(callout))(PUBL(callout_block) *) = NULL;
+PCRE_EXP_DATA_DEFN int   (*PUBL(stack_guard))(void) = NULL;
 #endif
 
 /* End of pcre_globals.c */
diff -Naurp pcre-8.34/pcre.h.in pcre-8.34.oden/pcre.h.in
--- pcre-8.34/pcre.h.in	2013-11-12 16:09:38.000000000 +0100
+++ pcre-8.34.oden/pcre.h.in	2014-02-19 14:59:22.964057477 +0100
@@ -491,36 +491,42 @@ PCRE_EXP_DECL void  (*pcre_free)(void *)
 PCRE_EXP_DECL void *(*pcre_stack_malloc)(size_t);
 PCRE_EXP_DECL void  (*pcre_stack_free)(void *);
 PCRE_EXP_DECL int   (*pcre_callout)(pcre_callout_block *);
+PCRE_EXP_DECL int   (*pcre_stack_guard)(void);
 
 PCRE_EXP_DECL void *(*pcre16_malloc)(size_t);
 PCRE_EXP_DECL void  (*pcre16_free)(void *);
 PCRE_EXP_DECL void *(*pcre16_stack_malloc)(size_t);
 PCRE_EXP_DECL void  (*pcre16_stack_free)(void *);
 PCRE_EXP_DECL int   (*pcre16_callout)(pcre16_callout_block *);
+PCRE_EXP_DECL int   (*pcre16_stack_guard)(void);
 
 PCRE_EXP_DECL void *(*pcre32_malloc)(size_t);
 PCRE_EXP_DECL void  (*pcre32_free)(void *);
 PCRE_EXP_DECL void *(*pcre32_stack_malloc)(size_t);
 PCRE_EXP_DECL void  (*pcre32_stack_free)(void *);
 PCRE_EXP_DECL int   (*pcre32_callout)(pcre32_callout_block *);
+PCRE_EXP_DECL int   (*pcre32_stack_guard)(void);
 #else   /* VPCOMPAT */
 PCRE_EXP_DECL void *pcre_malloc(size_t);
 PCRE_EXP_DECL void  pcre_free(void *);
 PCRE_EXP_DECL void *pcre_stack_malloc(size_t);
 PCRE_EXP_DECL void  pcre_stack_free(void *);
 PCRE_EXP_DECL int   pcre_callout(pcre_callout_block *);
+PCRE_EXP_DECL int   pcre_stack_guard(void);
 
 PCRE_EXP_DECL void *pcre16_malloc(size_t);
 PCRE_EXP_DECL void  pcre16_free(void *);
 PCRE_EXP_DECL void *pcre16_stack_malloc(size_t);
 PCRE_EXP_DECL void  pcre16_stack_free(void *);
 PCRE_EXP_DECL int   pcre16_callout(pcre16_callout_block *);
+PCRE_EXP_DECL int   pcre16_stack_guard(void);
 
 PCRE_EXP_DECL void *pcre32_malloc(size_t);
 PCRE_EXP_DECL void  pcre32_free(void *);
 PCRE_EXP_DECL void *pcre32_stack_malloc(size_t);
 PCRE_EXP_DECL void  pcre32_stack_free(void *);
 PCRE_EXP_DECL int   pcre32_callout(pcre32_callout_block *);
+PCRE_EXP_DECL int   pcre32_stack_guard(void);
 #endif  /* VPCOMPAT */
 
 /* User defined callback which provides a stack just before the match starts. */
diff -Naurp pcre-8.34/pcre_internal.h pcre-8.34.oden/pcre_internal.h
--- pcre-8.34/pcre_internal.h	2013-12-06 13:05:45.000000000 +0100
+++ pcre-8.34.oden/pcre_internal.h	2014-02-19 14:59:22.969057477 +0100
@@ -2341,7 +2341,7 @@ enum { ERR0,  ERR1,  ERR2,  ERR3,  ERR4,
        ERR50, ERR51, ERR52, ERR53, ERR54, ERR55, ERR56, ERR57, ERR58, ERR59,
        ERR60, ERR61, ERR62, ERR63, ERR64, ERR65, ERR66, ERR67, ERR68, ERR69,
        ERR70, ERR71, ERR72, ERR73, ERR74, ERR75, ERR76, ERR77, ERR78, ERR79,
-       ERR80, ERR81, ERR82, ERR83, ERR84, ERRCOUNT };
+       ERR80, ERR81, ERR82, ERR83, ERR84, ERR85, ERRCOUNT };
 
 /* JIT compiling modes. The function list is indexed by them. */
 
diff -Naurp pcre-8.34/pcreposix.c pcre-8.34.oden/pcreposix.c
--- pcre-8.34/pcreposix.c	2013-11-19 16:33:00.000000000 +0100
+++ pcre-8.34.oden/pcreposix.c	2014-02-19 14:59:22.968057477 +0100
@@ -170,7 +170,9 @@ static const int eint[] = {
   REG_BADPAT,  /* missing opening brace after \o */
   REG_BADPAT,  /* parentheses too deeply nested */
   REG_BADPAT,  /* invalid range in character class */
-  REG_BADPAT   /* group name must start with a non-digit */
+  REG_BADPAT,  /* group name must start with a non-digit */
+  /* 85 */
+  REG_BADPAT   /* parentheses too deeply nested (stack check) */
 };
 
 /* Table of texts corresponding to POSIX error codes */
diff -Naurp pcre-8.34/pcretest.c pcre-8.34.oden/pcretest.c
--- pcre-8.34/pcretest.c	2013-11-25 16:06:36.000000000 +0100
+++ pcre-8.34.oden/pcretest.c	2014-02-19 14:59:22.970057477 +0100
@@ -233,6 +233,9 @@ argument, the casting might be incorrect
 #define SET_PCRE_CALLOUT8(callout) \
   pcre_callout = callout
 
+#define SET_PCRE_STACK_GUARD8(stack_guard) \
+  pcre_stack_guard = stack_guard
+
 #define PCRE_ASSIGN_JIT_STACK8(extra, callback, userdata) \
    pcre_assign_jit_stack(extra, callback, userdata)
 
@@ -317,6 +320,9 @@ argument, the casting might be incorrect
 #define SET_PCRE_CALLOUT16(callout) \
   pcre16_callout = (int (*)(pcre16_callout_block *))callout
 
+#define SET_PCRE_STACK_GUARD16(stack_guard) \
+  pcre16_stack_guard = (int (*)(void))stack_guard
+
 #define PCRE_ASSIGN_JIT_STACK16(extra, callback, userdata) \
   pcre16_assign_jit_stack((pcre16_extra *)extra, \
     (pcre16_jit_callback)callback, userdata)
@@ -406,6 +412,9 @@ argument, the casting might be incorrect
 #define SET_PCRE_CALLOUT32(callout) \
   pcre32_callout = (int (*)(pcre32_callout_block *))callout
 
+#define SET_PCRE_STACK_GUARD32(stack_guard) \
+  pcre32_stack_guard = (int (*)(void))stack_guard
+
 #define PCRE_ASSIGN_JIT_STACK32(extra, callback, userdata) \
   pcre32_assign_jit_stack((pcre32_extra *)extra, \
     (pcre32_jit_callback)callback, userdata)
@@ -533,6 +542,14 @@ cases separately. */
   else \
     SET_PCRE_CALLOUT8(callout)
 
+#define SET_PCRE_STACK_GUARD(stack_guard) \
+  if (pcre_mode == PCRE32_MODE) \
+    SET_PCRE_STACK_GUARD32(stack_guard); \
+  else if (pcre_mode == PCRE16_MODE) \
+    SET_PCRE_STACK_GUARD16(stack_guard); \
+  else \
+    SET_PCRE_STACK_GUARD8(stack_guard)
+
 #define STRLEN(p) (pcre_mode == PCRE32_MODE ? STRLEN32(p) : pcre_mode == PCRE16_MODE ? STRLEN16(p) : STRLEN8(p))
 
 #define PCRE_ASSIGN_JIT_STACK(extra, callback, userdata) \
@@ -756,6 +773,12 @@ the three different cases. */
   else \
     G(SET_PCRE_CALLOUT,BITTWO)(callout)
 
+#define SET_PCRE_STACK_GUARD(stack_guard) \
+  if (pcre_mode == G(G(PCRE,BITONE),_MODE)) \
+    G(SET_PCRE_STACK_GUARD,BITONE)(stack_guard); \
+  else \
+    G(SET_PCRE_STACK_GUARD,BITTWO)(stack_guard)
+
 #define STRLEN(p) ((pcre_mode == G(G(PCRE,BITONE),_MODE)) ? \
   G(STRLEN,BITONE)(p) : G(STRLEN,BITTWO)(p))
 
@@ -897,6 +920,7 @@ the three different cases. */
 #define PCHARSV                   PCHARSV8
 #define READ_CAPTURE_NAME         READ_CAPTURE_NAME8
 #define SET_PCRE_CALLOUT          SET_PCRE_CALLOUT8
+#define SET_PCRE_STACK_GUARD      SET_PCRE_STACK_GUARD8
 #define STRLEN                    STRLEN8
 #define PCRE_ASSIGN_JIT_STACK     PCRE_ASSIGN_JIT_STACK8
 #define PCRE_COMPILE              PCRE_COMPILE8
@@ -927,6 +951,7 @@ the three different cases. */
 #define PCHARSV                   PCHARSV16
 #define READ_CAPTURE_NAME         READ_CAPTURE_NAME16
 #define SET_PCRE_CALLOUT          SET_PCRE_CALLOUT16
+#define SET_PCRE_STACK_GUARD      SET_PCRE_STACK_GUARD16
 #define STRLEN                    STRLEN16
 #define PCRE_ASSIGN_JIT_STACK     PCRE_ASSIGN_JIT_STACK16
 #define PCRE_COMPILE              PCRE_COMPILE16
@@ -957,6 +982,7 @@ the three different cases. */
 #define PCHARSV                   PCHARSV32
 #define READ_CAPTURE_NAME         READ_CAPTURE_NAME32
 #define SET_PCRE_CALLOUT          SET_PCRE_CALLOUT32
+#define SET_PCRE_STACK_GUARD      SET_PCRE_STACK_GUARD32
 #define STRLEN                    STRLEN32
 #define PCRE_ASSIGN_JIT_STACK     PCRE_ASSIGN_JIT_STACK32
 #define PCRE_COMPILE              PCRE_COMPILE32
@@ -1015,6 +1041,7 @@ static int first_callout;
 static int jit_was_used;
 static int locale_set = 0;
 static int show_malloc;
+static int stack_guard_return;
 static int use_utf;
 static const unsigned char *last_callout_mark = NULL;
 
@@ -2201,6 +2228,18 @@ return p;
 
 
 /*************************************************
+*            Stack guard function                *
+*************************************************/
+
+/* Called from PCRE when set in pcre_stack_guard. We give an error (non-zero)
+return when a count overflows. */
+
+static int stack_guard(void)
+{
+return stack_guard_return;
+}
+
+/*************************************************
 *              Callout function                  *
 *************************************************/
 
@@ -3439,6 +3478,7 @@ while (!done)
 
   use_utf = 0;
   debug_lengths = 1;
+  SET_PCRE_STACK_GUARD(NULL);
 
   if (extend_inputline(infile, buffer, "  re> ") == NULL) break;
   if (infile != stdin) fprintf(outfile, "%s", (char *)buffer);
@@ -3739,6 +3779,21 @@ while (!done)
       case 'P': do_posix = 1; break;
 #endif
 
+      case 'Q':
+      switch (*pp)
+        {
+        case '0': 
+        case '1':
+        stack_guard_return = *pp++ - '0';
+        break;  
+
+        default:
+        fprintf(outfile, "** Missing 0 or 1 after /Q\n");
+        goto SKIP_DATA;
+        }
+      SET_PCRE_STACK_GUARD(stack_guard);
+      break;
+
       case 'S':
       do_study = 1;
       for (;;)
diff -Naurp pcre-8.34/testdata/testinput2 pcre-8.34.oden/testdata/testinput2
--- pcre-8.34/testdata/testinput2	2013-12-03 16:51:53.000000000 +0100
+++ pcre-8.34.oden/testdata/testinput2	2014-02-19 15:02:16.593067186 +0100
@@ -4045,4 +4045,12 @@ backtracking verbs. --/
     
 /[a[:<:]] should give error/ 
 
+/ -- Test stack check external calls --/ 
+
+/(((((a)))))/Q0
+
+/(((((a)))))/Q1
+
+/(((((a)))))/Q
+
 /-- End of testinput2 --/
diff -Naurp pcre-8.34/testdata/testoutput2 pcre-8.34.oden/testdata/testoutput2
--- pcre-8.34/testdata/testoutput2	2013-12-03 16:52:35.000000000 +0100
+++ pcre-8.34.oden/testdata/testoutput2	2014-02-19 15:03:04.993069892 +0100
@@ -14125,4 +14125,14 @@ No match
 /[a[:<:]] should give error/ 
 Failed: unknown POSIX class name at offset 4
 
+/ -- Test stack check external calls --/ 
+
+/(((((a)))))/Q0
+
+/(((((a)))))/Q1
+Failed: parentheses are too deeply nested (stack check) at offset 0
+
+/(((((a)))))/Q
+** Missing 0 or 1 after /Q
+
 /-- End of testinput2 --/
